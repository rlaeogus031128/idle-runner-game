<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Idle Runner — Stage, Rebirth, Dash (v4)</title>
<style>
  :root{
    --panel-w: 320px;
    --bg:#0e0f12; --fg:#e6e6e6; --accent:#6cf; --muted:#9aa0a6;
  }
  html,body{height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, sans-serif;}
  .wrap{display:flex; height:100vh; overflow:hidden;}
  canvas{flex:1; background:linear-gradient(#1b1f27,#101319);}
  .panel{width:var(--panel-w); padding:12px 12px 16px; box-sizing:border-box; border-left:1px solid #1f232b; background:#14161c;}
  h1{font-size:18px; margin:0 0 6px;}
  .row{display:flex; gap:8px; flex-wrap:wrap; margin:8px 0;}
  .stat{flex:1 1 46%; background:#191c24; padding:8px; border-radius:8px; font-size:12px; line-height:1.3;}
  .stat b{display:block; font-size:12px; color:#cde6ff;}
  button, .toggle{cursor:pointer; border:none; padding:8px 10px; border-radius:8px; background:#232734; color:#e9f2ff; font-size:12px;}
  button:disabled{opacity:.5; cursor:not-allowed;}
  .controls{display:flex; gap:8px; flex-wrap:wrap; margin-top:6px;}
  .fine{color:var(--muted); font-size:12px; margin-top:6px;}
  .bar{height:8px; background:#2a2f3f; border-radius:999px; overflow:hidden; margin:6px 0 4px;}
  .bar>span{display:block; height:100%;}
  .hp{background:#ff5d73;}
  .ehp{background:#ffae46;}
  .gold{color:#ffd76a; font-weight:700;}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;}
  .tag{display:inline-block; padding:2px 8px; border-radius:999px; font-size:11px; background:#203049; color:#cfe8ff; margin-left:6px;}
  .tag.boss{background:#492030; color:#ffd0d6;}
  .rebirth{background:#2a2f1f; color:#e8ffd4; border:1px solid #324a2c;}
  .switch {display:inline-flex; align-items:center; gap:6px; font-size:12px;}
  .switch input {accent-color:#5ec8ff; width:16px; height:16px;}
  .hudline{display:flex; align-items:center; justify-content:space-between; gap:8px; margin:6px 0;}
  .pill{font-size:11px; padding:2px 8px; border:1px solid #2a3240; border-radius:999px; color:#cfe8ff; background:#192131;}
  @media (max-width: 900px) {
    .wrap{flex-direction:column;}
    canvas{height:60vh; width:100%;}
    .panel{width:100%; height:40vh; overflow:auto; border-left:none; border-top:1px solid #1f232b;}
  }
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game" width="960" height="540"></canvas>
  <aside class="panel">
    <div class="hudline">
      <h1>Idle Runner</h1>
    </div>
    <div class="hudline">
      <div>스테이지: <span id="stage" class="mono">1</span><span id="stageTag" class="tag" style="display:none">보스</span></div>
      <div>처치: <span id="kills" class="mono">0</span> / 10</div>
    </div>
    <div class="hudline">
      <div>환생(레이어2): <span id="rebirths" class="mono">0</span></div>
      <div>골드: <span id="gold" class="gold mono">0</span></div>
    </div>
    <div class="row" style="margin-top:6px">
      <label class="switch"><input type="checkbox" id="bossToggle" checked> 보스 등장</label>
    </div>
    <div class="fine">적은 화면 밖 오른쪽에서 생성됩니다. 스페이스로 1초 대시(쿨타임 2초).</div>

    <h2 style="font-size:14px;margin:10px 0 4px;">플레이어</h2>
    <div>HP <span class="mono" id="phpLabel"></span>
      <div class="bar"><span id="phpBar" class="hp" style="width:100%"></span></div>
    </div>
    <div class="row">
      <div class="stat"><b>공격력</b><span id="patk"></span><br>
        <button id="upATK"></button></div>
      <div class="stat"><b>방어력</b><span id="pdef"></span><br>
        <button id="upDEF"></button></div>
      <div class="stat"><b>공격속도</b><span id="paspd"></span><br>
        <button id="upASPD"></button></div>
      <!-- 고급 공격속도 업그레이드: 기본 2레벨 달성 시 표시 -->
      <div class="stat" id="aspdAdvStat" style="display:none; flex:1 1 100%">
        <b>고급 공격속도</b>
        <span id="paspdAdv"></span><br>
        <button id="upASPD_ADV"></button>
      </div>
      <div class="stat"><b>체력</b><span id="php"></span><br>
        <button id="upHP"></button></div>
      <div class="stat" style="flex:1 1 100%"><b>이동속도</b><span id="pspd"></span><br>
        <button id="upMSPD"></button></div>
    </div>

    <h2 style="font-size:14px;margin:10px 0 4px;">적</h2>
    <div>HP <span class="mono" id="ehpLabel"></span>
      <div class="bar"><span id="ehpBar" class="ehp" style="width:100%"></span></div>
    </div>
    <div class="row">
      <div class="stat"><b>공격력</b><span id="eatk"></span></div>
      <div class="stat"><b>방어력</b><span id="edef"></span></div>
      <div class="stat"><b>공격속도</b><span id="easpd"></span></div>
      <div class="stat"><b>리워드</b><span id="erew"></span></div>
    </div>

    <h2 style="font-size:14px;margin:10px 0 4px;">업그레이드</h2>
    <div class="row">
      <div class="stat"><b>골드 획득량</b><span id="goldMulLabel"></span><br>
        <button id="upGoldMul"></button></div>
    </div>

    <div class="controls">
      <button id="pauseBtn">일시정지(P)</button>
      <button id="saveBtn">저장(S)</button>
      <button id="loadBtn">불러오기(L)</button>
      <button id="resetBtn">리셋</button>
      <button id="rebirthBtn" class="rebirth" disabled>환생 (스테이지 10부터)</button>
    </div>
    <div class="fine">단축키: P(일시정지) / S(저장) / L(불러오기) / Space(대시)</div>
  </aside>
</div>

<script>
(() => {
  const cv = document.getElementById('game');
  const ctx = cv.getContext('2d');

  // 변경: 공속 상한 3.0/s
  const CAPS = { ASPD: 3.0, MSPD: 250 };
  const RESPAWN_MS = 3000;
  const DASH = { DUR: 1000, CD: 2000 };

  const state = {
    paused:false, cameraX:0, inCombat:false,
    lastTime:performance.now(),
    spawnCooldown:0, needSpawn:true, nextIsBoss:false,
    dead:false, respawnAt:0,
    dashActive:false, dashUntil:0, dashCdUntil:0
  };

  const prog = { stage:1, killsThisStage:0, rebirths:0, bossEnabled:true };
  function layer2Mult(){ return Math.pow(2, prog.rebirths); }

  const basePlayer = { atk:10, def:3, aspd:1.0, maxHp:70, moveSpeed:140 };
  const player = { x:40, y:380, w:32, h:42, color:'#5ec8ff',
    atk:0, def:0, aspd:0, maxHp:0, hp:0, moveSpeed:0, nextAtk:0 };

  // economy.level에 aspd_adv 추가
  const economy = { gold:0, level:{ atk:1, def:1, aspd:1, aspd_adv:0, hp:1, mspd:1, goldmul:1 } };
  const baseCost = { atk:20, def:20, aspd:30, hp:25, mspd:25, goldmul:50 };
  function costOf(key){ const lv=economy.level[key]; return Math.floor(baseCost[key]*Math.pow(1.35, lv-1)); }
  function goldMul(){ return Math.pow(1.10, (economy.level.goldmul||1)-1); }

  // 고급 공속 비용: 2000, 이후 +20%
  function costOfAspdAdv(){ const lv = economy.level.aspd_adv||0; return Math.ceil(2000 * Math.pow(1.2, lv)); }

  function randBetween(a,b){ return a + Math.random()*(b-a); }
  function stageScale(stage){
    const s = Math.pow(1 + 0.16*stage, 1.08);
    const r = Math.pow(1 + 0.15*stage, 1.04);
    return {stat:s, reward:r};
  }

  const SHAPES = ['square','triangle','circle'];

  function makeEnemy(isBoss=false){
    const sc = stageScale(prog.stage), b = prog.stage;
    let baseHp = 42 + b*6.5 * sc.stat;
    const baseAtk = 6  + b*2.2 * sc.stat;
    let baseDef = Math.max(0, Math.round((b-1)*0.5 * sc.stat));
    const baseAspd = 1.0 + Math.min(1.5, b*0.05);
    const baseReward = (6 + b*3.0) * sc.reward;

    let shape = isBoss ? 'square' : SHAPES[Math.floor(Math.random()*SHAPES.length)];
    let hp = baseHp, atk = baseAtk, def = baseDef, aspd = baseAspd, reward = baseReward;
    if(shape === 'triangle'){ atk *= 1.2; }
    if(shape === 'square'){   def = Math.round(def*1.5 + 1); }
    if(shape === 'circle'){   hp *= 1.25; }

    const bossMul = isBoss ? 2.4 : 1.0;
    hp = Math.round(hp * bossMul);
    atk = Math.round(atk * bossMul);
    def = Math.round(def * (isBoss? 1.7:1.0));
    aspd = +(aspd * (isBoss? 1.1:1.0)).toFixed(2);
    reward = Math.round(reward * (isBoss? 3.0:1.0));

    const spawnGap = isBoss ? randBetween(900,1100) : randBetween(700,950);
    return {
      x: player.x + spawnGap,
      y: 390,
      w: isBoss ? 52 : 30,
      h: isBoss ? 60 : 38,
      color: isBoss ? '#ff2d55' : (shape==='triangle' ? '#ff7a66' : shape==='square' ? '#ff6b6b' : '#ff9966'),
      atk, def, aspd,
      maxHp: hp, hp,
      nextAtk: 0,
      reward,
      isBoss,
      shape
    }
  }
  let enemy = null;

  function applyBaseToPlayer(){
    player.atk = Math.round(basePlayer.atk * layer2Mult());
    player.def = basePlayer.def;
    player.aspd = Math.min(CAPS.ASPD, basePlayer.aspd);
    player.maxHp = Math.round(basePlayer.maxHp * layer2Mult());
    player.moveSpeed = Math.min(CAPS.MSPD, basePlayer.moveSpeed);
    player.hp = player.maxHp;
  }
  function applyLevelUpgrades(){
    const L = economy.level, la=(L.atk||1)-1, ld=(L.def||1)-1, ls=(L.aspd||1)-1, lh=(L.hp||1)-1, lm=(L.mspd||1)-1, lsa=(L.aspd_adv||0);
    if(la>0) player.atk += 3*la;
    if(ld>0) player.def += 2*ld;
    if(ls>0) player.aspd = Math.min(CAPS.ASPD, player.aspd + 0.20*ls);
    if(lsa>0) player.aspd = Math.min(CAPS.ASPD, +(player.aspd + 0.10*lsa).toFixed(2));
    if(lh>0){ const add=15*lh; player.maxHp += add; player.hp = Math.min(player.hp + add, player.maxHp); }
    if(lm>0) player.moveSpeed = Math.min(CAPS.MSPD, player.moveSpeed + 15*lm);
  }
  applyBaseToPlayer();

  const $ = id => document.getElementById(id);
  const el = {
    stage: $('stage'), stageTag:$('stageTag'), kills:$('kills'), rebirths:$('rebirths'),
    gold: $('gold'),
    phpLabel: $('phpLabel'), phpBar:$('phpBar'),
    ehpLabel: $('ehpLabel'), ehpBar:$('ehpBar'),
    patk: $('patk'), pdef: $('pdef'), paspd: $('paspd'), php: $('php'), pspd: $('pspd'),
    paspdAdv: $('paspdAdv'), aspdAdvStat: $('aspdAdvStat'),
    eatk: $('eatk'), edef: $('edef'), easpd: $('easpd'), erew: $('erew'),
    upATK: $('upATK'), upDEF: $('upDEF'), upASPD: $('upASPD'), upASPD_ADV: $('upASPD_ADV'), upHP: $('upHP'), upMSPD: $('upMSPD'),
    upGoldMul: $('upGoldMul'), goldMulLabel: $('goldMulLabel'),
    pauseBtn: $('pauseBtn'), saveBtn:$('saveBtn'), loadBtn:$('loadBtn'), resetBtn:$('resetBtn'),
    rebirthBtn:$('rebirthBtn'),
    bossToggle:$('bossToggle')
  };
  function fmt(n){ return Number.isInteger(n)? n : n.toFixed(2); }

  function syncUI(){
    el.stage.textContent = prog.stage;
    el.kills.textContent = Math.min(10, prog.killsThisStage);
    el.rebirths.textContent = prog.rebirths;
    el.stageTag.style.display = enemy && enemy.isBoss ? 'inline-block' : 'none';
    el.gold.textContent = economy.gold;

    el.patk.textContent = `현재 ${player.atk}  | 레벨 ${economy.level.atk}`;
    el.pdef.textContent = `현재 ${player.def}  | 레벨 ${economy.level.def}`;
    el.paspd.textContent = `현재 ${fmt(player.aspd)} /s | 레벨 ${economy.level.aspd} (캡 ${CAPS.ASPD}/s)`;
    el.php.textContent  = `현재 최대 ${player.maxHp}  | 레벨 ${economy.level.hp}`;
    el.pspd.textContent = `현재 ${Math.round(player.moveSpeed)} px/s | 레벨 ${economy.level.mspd} (캡 ${CAPS.MSPD}px/s)`;

    el.phpLabel.textContent = `${Math.max(0, Math.ceil(player.hp))}/${player.maxHp}`;
    if(enemy){
      el.ehpLabel.textContent = `${Math.max(0, Math.ceil(enemy.hp))}/${enemy.maxHp}`;
      el.ehpBar.style.width = `${Math.max(0, (enemy.hp/ enemy.maxHp)*100)}%`;
      el.eatk.textContent = enemy.atk; el.edef.textContent = enemy.def;
      el.easpd.textContent = `${fmt(enemy.aspd)} /s`; el.erew.textContent  = `${Math.round(enemy.reward * goldMul())} 골드`;
    }else{
      el.ehpLabel.textContent = `-/-`; el.ehpBar.style.width = `0%`;
      el.eatk.textContent = '-'; el.edef.textContent = '-'; el.easpd.textContent = '-'; el.erew.textContent  = '-';
    }
    el.phpBar.style.width = `${Math.max(0, (player.hp/player.maxHp)*100)}%`;

    // 업그레이드 버튼 텍스트/활성
    el.upATK.textContent  = `공격력 업 (${costOf('atk')} G)`;
    el.upDEF.textContent  = `방어력 업 (${costOf('def')} G)`;

    // 공속: 기본 업그레이드(레벨 2까지)
    if(player.aspd >= CAPS.ASPD - 1e-9){
      el.upASPD.textContent = `공속 업 (MAX)`;
      el.upASPD.disabled = true;
    }else if(economy.level.aspd >= 2){
      el.upASPD.textContent = `공속 업 (2레벨 도달 - 고급 사용)`;
      el.upASPD.disabled = true;
    }else{
      el.upASPD.textContent = `공속 업 (+0.2/s, ${costOf('aspd')} G)`;
      el.upASPD.disabled = economy.gold < costOf('aspd');
    }

    // 고급 공속: 2레벨 달성 시 표시
    const showAdv = economy.level.aspd >= 2;
    el.aspdAdvStat.style.display = showAdv ? 'block' : 'none';
    if(showAdv){
      const advCost = costOfAspdAdv();
      el.paspdAdv.textContent = `레벨 ${economy.level.aspd_adv} | 다음 +0.1/s`;
      if(player.aspd >= CAPS.ASPD - 1e-9){
        el.upASPD_ADV.textContent = `고급 공속 업 (MAX)`;
        el.upASPD_ADV.disabled = true;
      }else{
        el.upASPD_ADV.textContent = `고급 공속 업 (+0.1/s, ${advCost} G)`;
        el.upASPD_ADV.disabled = economy.gold < advCost;
      }
    }

    el.upHP.textContent   = `체력 업 (${costOf('hp')} G)`;
    el.upMSPD.textContent = `이속 업 (${costOf('mspd')} G)`;

    // 골드 멀티: 표시/비용/활성 일치 (버그 수정)
    const gmCost = costOf('goldmul');
    el.upGoldMul.textContent = `골드 획득량 +10% (${gmCost} G)`;
    el.goldMulLabel.textContent = `현재 배수 ×${goldMul().toFixed(2)}`;
    el.upGoldMul.disabled = economy.gold < gmCost;

    el.pauseBtn.textContent = state.paused ? '계속(P)' : '일시정지(P)';
    el.rebirthBtn.disabled = !(prog.stage >= 10 && !state.inCombat && !state.dead);
    el.bossToggle.checked = prog.bossEnabled;
  }

  // ---- Upgrades ----
  el.upATK.onclick = ()=> tryBuy('atk', ()=>{ player.atk += 3; });
  el.upDEF.onclick = ()=> tryBuy('def', ()=>{ player.def += 2; });
  el.upASPD.onclick= ()=> {
    if(economy.level.aspd >= 2 || player.aspd >= CAPS.ASPD - 1e-9) return;
    const c = costOf('aspd');
    if(economy.gold >= c){
      economy.gold -= c; economy.level.aspd++;
      player.aspd = Math.min(CAPS.ASPD, player.aspd + 0.20);
      flash('공속 +0.2/s');
      syncUI(); saveAuto();
    }
  };
  el.upASPD_ADV.onclick = ()=>{
    if(player.aspd >= CAPS.ASPD - 1e-9) return;
    const c = costOfAspdAdv();
    if(economy.gold >= c){
      economy.gold -= c; economy.level.aspd_adv = (economy.level.aspd_adv||0) + 1;
      player.aspd = Math.min(CAPS.ASPD, +(player.aspd + 0.10).toFixed(2));
      flash('고급 공속 +0.1/s');
      syncUI(); saveAuto();
    }
  };
  el.upHP.onclick  = ()=> tryBuy('hp',  ()=>{ const oldMax=player.maxHp; player.maxHp += 15; const gain=player.maxHp-oldMax; player.hp = Math.min(player.hp + gain, player.maxHp); });
  el.upMSPD.onclick= ()=> tryBuy('mspd',()=>{ player.moveSpeed = Math.min(CAPS.MSPD, player.moveSpeed + 15); });

  // 골드 멀티: 표시/차감 동일 함수 사용
  el.upGoldMul.onclick = ()=> {
    const key='goldmul';
    const cost = costOf(key);
    if(economy.gold >= cost){
      economy.gold -= cost; economy.level[key] = economy.level[key] + 1;
      flash('골드 획득량 +10%'); syncUI(); saveAuto();
    }
  };

  function tryBuy(key, apply){
    const c = costOf(key);
    if(economy.gold >= c){ economy.gold -= c; economy.level[key]++; apply(); syncUI(); saveAuto(); }
  }

  function packSave(){ return JSON.stringify({ economy, prog, playerBase: basePlayer }); }
  function applySave(obj){
    if(!obj) return;
    if(obj.economy){
      economy.gold = obj.economy.gold ?? economy.gold;
      economy.level = Object.assign({atk:1,def:1,aspd:1,aspd_adv:0,hp:1,mspd:1,goldmul:1}, obj.economy.level||{});
    }
    if(obj.prog){
      prog.stage = obj.prog.stage ?? prog.stage;
      prog.killsThisStage = obj.prog.killsThisStage ?? prog.killsThisStage;
      prog.rebirths = obj.prog.rebirths ?? prog.rebirths;
      prog.bossEnabled = (obj.prog.bossEnabled ?? prog.bossEnabled);
    }
    if(obj.playerBase){ Object.assign(basePlayer, obj.playerBase); }
    applyBaseToPlayer();
    applyLevelUpgrades();
    player.x = 40; state.cameraX=0; state.inCombat=false; state.dead=false;
    enemy = null; state.needSpawn = true; state.spawnCooldown = 0.5;
    syncUI();
  }
  function saveAuto(){ localStorage.setItem('idleRunnerSave_v4a', packSave()); }
  function saveManual(){ saveAuto(); flash('저장 완료'); }
  function loadManual(){
    const raw = localStorage.getItem('idleRunnerSave_v4a') ||
                localStorage.getItem('idleRunnerSave_v4') ||
                localStorage.getItem('idleRunnerSave_v3') ||
                localStorage.getItem('idleRunnerSave_v2') ||
                localStorage.getItem('idleRunnerSave');
    if(raw){ try{ applySave(JSON.parse(raw)); flash('불러오기 완료'); }catch{} }
  }
  function resetAll(){
    localStorage.removeItem('idleRunnerSave_v4a');
    localStorage.removeItem('idleRunnerSave_v4');
    localStorage.removeItem('idleRunnerSave_v3');
    localStorage.removeItem('idleRunnerSave_v2');
    localStorage.removeItem('idleRunnerSave');
    economy.gold=0; economy.level={atk:1,def:1,aspd:1,aspd_adv:0,hp:1,mspd:1,goldmul:1};
    prog.stage=1; prog.killsThisStage=0; prog.rebirths=0; prog.bossEnabled=true;
    applyBaseToPlayer(); player.x=40; state.cameraX=0; state.inCombat=false; state.dead=false;
    enemy=null; state.needSpawn=true; state.spawnCooldown=0.5;
    syncUI(); flash('리셋됨');
  }

  function doRebirth(){
    if(prog.stage < 10 || state.inCombat || state.dead) return;
    prog.rebirths += 1;
    economy.gold = 0; economy.level={atk:1,def:1,aspd:1,aspd_adv:0,hp:1,mspd:1,goldmul:1};
    applyBaseToPlayer();
    player.x = 40; player.hp = player.maxHp;
    prog.stage = 1; prog.killsThisStage = 0;
    enemy = null; state.needSpawn = true; state.spawnCooldown = 0.6;
    flash('환생 완료: 공격력·체력 +100% (영구)');
    syncUI(); saveAuto();
  }

  document.getElementById('pauseBtn').onclick = ()=>{ state.paused = !state.paused; syncUI(); };
  document.getElementById('saveBtn').onclick = saveManual;
  document.getElementById('loadBtn').onclick = loadManual;
  document.getElementById('resetBtn').onclick = resetAll;
  document.getElementById('rebirthBtn').onclick = doRebirth;
  document.getElementById('bossToggle').onchange = (e)=>{ prog.bossEnabled = e.target.checked; saveAuto(); flash(`보스 ${prog.bossEnabled?'ON':'OFF'}`); };

  window.addEventListener('keydown', (e)=>{
    if(e.key==='p' || e.key==='P'){ state.paused = !state.paused; syncUI(); }
    if(e.key==='s' || e.key==='S'){ saveManual(); }
    if(e.key==='l' || e.key==='L'){ loadManual(); }
    if((e.code === 'Space' || e.key === ' ') && !state.paused && !state.dead){
      const now = performance.now();
      if(!state.dashActive && now >= state.dashCdUntil){
        state.dashActive = true;
        state.dashUntil = now + DASH.DUR;
        flash('대시!');
      }
      e.preventDefault();
    }
  });
  cv.addEventListener('click', ()=>{ if(state.dead){ respawnNow(performance.now()); }});

  let toastTimer=0, toastMsg='';
  function flash(msg){ toastMsg=msg; toastTimer=1.8; }

  function rectsOverlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
  function damageCalc(atk, def){ return Math.max(1, atk - def); }

  const explosions = [];
  function spawnExplosion(x, y, color){
    const N = 20 + Math.floor(Math.random()*10);
    for(let i=0;i<N;i++){
      const ang = Math.random()*Math.PI*2;
      const spd = 60 + Math.random()*140;
      explosions.push({
        x, y,
        vx: Math.cos(ang)*spd,
        vy: Math.sin(ang)*spd,
        life: 0.5 + Math.random()*0.4,
        r: 3 + Math.random()*3,
        color
      });
    }
  }

  function requestSpawn(){ state.spawnCooldown = randBetween(0.8, 1.6); state.needSpawn = true; }
  function respawnNow(now){
    if(!state.dead) return;
    state.dead=false; player.hp=player.maxHp;
    if(enemy){
      state.inCombat = true;
      player.nextAtk = now + 120;
      enemy.nextAtk = now + 220;
    }else{
      requestSpawn();
    }
    flash('부활!');
  }

  function tick(ts){
    const dt = Math.min(0.033, (ts - state.lastTime)/1000); state.lastTime = ts;
    if(!state.paused){ update(dt, ts); draw(ts); } else { draw(ts); }
    requestAnimationFrame(tick);
  }

  function update(dt, ts){
    if(state.dead){
      if(ts >= state.respawnAt){ respawnNow(ts); }
      for(let i=explosions.length-1;i>=0;i--){
        const p = explosions[i]; p.life -= dt; p.x += p.vx*dt; p.y += p.vy*dt; p.vy += 300*dt;
        if(p.life<=0) explosions.splice(i,1);
      }
      syncUI(); return;
    }

    if(state.dashActive && ts >= state.dashUntil){
      state.dashActive = false;
      state.dashCdUntil = ts + DASH.CD;
    }

    if(!enemy && !state.inCombat){
      state.spawnCooldown -= dt;
      if(state.spawnCooldown <= 0){
        if(prog.killsThisStage >= 10 && prog.bossEnabled){ state.nextIsBoss = true; }
        enemy = makeEnemy(state.nextIsBoss);
        state.nextIsBoss = false; state.needSpawn = false;
      }
    }

    if(!state.inCombat){
      const dashMult = state.dashActive ? 2 : 1;
      player.x += player.moveSpeed * dashMult * dt;
      const targetCam = player.x - 200; state.cameraX += (targetCam - state.cameraX) * 0.1;
      if(enemy && rectsOverlap(player, enemy)){
        player.x = enemy.x - player.w; state.inCombat = true;
        player.nextAtk = ts + 120; enemy.nextAtk = ts + 220;
      }
    }else{
      if(ts >= player.nextAtk){ enemy.hp -= damageCalc(player.atk, enemy.def); player.nextAtk = ts + (1000 / player.aspd); }
      if(ts >= enemy.nextAtk){ player.hp -= damageCalc(enemy.atk, player.def); enemy.nextAtk = ts + (1000 / enemy.aspd); }
      if(enemy.hp <= 0){
        const wasBoss = enemy.isBoss;
        const drop = Math.round(enemy.reward * goldMul());
        economy.gold += drop;
        spawnExplosion(enemy.x + enemy.w/2, enemy.y + enemy.h/2, enemy.color);
        enemy = null; state.inCombat = false;
        if(wasBoss){
          prog.stage += 1; prog.killsThisStage = 0; player.hp = player.maxHp;
          flash(`보스 격파! 스테이지 ${prog.stage}`);
        }else{
          prog.killsThisStage += 1;
          if(prog.killsThisStage >= 10 && prog.bossEnabled){ flash('보스가 다가오는 중!'); }
          if(prog.killsThisStage >= 10 && !prog.bossEnabled){ prog.killsThisStage = 0; }
        }
        requestSpawn();
      }else if(player.hp <= 0){
        spawnExplosion(player.x + player.w/2, player.y + player.h/2, '#5ec8ff');
        player.hp = 0; state.inCombat = false; state.dead = true; state.respawnAt = ts + RESPAWN_MS;
        flash('사망! 3초 후 부활 (클릭 시 즉시)');
      }
    }
    for(let i=explosions.length-1;i>=0;i--){
      const p = explosions[i]; p.life -= dt; p.x += p.vx*dt; p.y += p.vy*dt; p.vy += 300*dt;
      if(p.life<=0) explosions.splice(i,1);
    }
    syncUI();
    if(toastTimer > 0) toastTimer -= dt;
  }

  function draw(ts){
    const cam = state.cameraX;
    ctx.clearRect(0,0,cv.width,cv.height);
    const groundY = 430;
    ctx.fillStyle = '#0b0f14'; ctx.fillRect(0, groundY, cv.width, cv.height-groundY);
    ctx.strokeStyle = '#1f2733'; ctx.lineWidth = 2;
    for(let i=0;i<6;i++){ const y = groundY - 6 - i*18; ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(cv.width, y); ctx.stroke(); }
    ctx.fillStyle = '#1a2130';
    for(let gx = -((cam%80)+80); gx < cv.width; gx += 80){ ctx.fillRect(gx, groundY-180, 2, 160); }

    if(enemy){
      const ex = Math.floor(enemy.x - cam), ey = enemy.y, ew = enemy.w, eh = enemy.h;
      ctx.fillStyle = enemy.color;
      if(enemy.isBoss){
        ctx.fillRect(ex, ey, ew, eh);
        ctx.strokeStyle = '#ffb3c0';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(ex + ew*0.25, ey); ctx.lineTo(ex + ew*0.15, ey - eh*0.3);
        ctx.moveTo(ex + ew*0.75, ey); ctx.lineTo(ex + ew*0.85, ey - eh*0.3);
        ctx.stroke();
      }else{
        if(enemy.shape === 'square'){
          ctx.fillRect(ex, ey, ew, eh);
        }else if(enemy.shape === 'triangle'){
          ctx.beginPath();
          ctx.moveTo(ex + ew/2, ey);
          ctx.lineTo(ex, ey + eh);
          ctx.lineTo(ex + ew, ey + eh);
          ctx.closePath();
          ctx.fill();
        }else{
          ctx.beginPath();
          ctx.arc(ex + ew/2, ey + eh/2, Math.min(ew,eh)/2, 0, Math.PI*2);
          ctx.fill();
        }
      }
      ctx.fillStyle = enemy.isBoss ? '#ffd2e0' : '#ffd2a1'; ctx.font = '12px ui-monospace, monospace';
      const label = (enemy.isBoss?'BOSS ':'E ') + `HP:${Math.max(0,Math.ceil(enemy.hp))}`;
      ctx.fillText(label, ex-6, ey-6);
    }

    ctx.fillStyle = player.color; ctx.fillRect(Math.floor(player.x - cam), player.y, player.w, player.h);
    ctx.fillStyle = '#c7e7ff'; ctx.font = '12px ui-monospace, monospace';
    ctx.fillText(`P HP:${Math.max(0,Math.ceil(player.hp))}`, Math.floor(player.x - cam)-4, player.y-6);

    if(state.inCombat && enemy){
      const t = (ts/120)%1; ctx.strokeStyle = enemy.isBoss ? (t<0.5 ? '#ff6ea3' : '#ffd1e6') : (t<0.5 ? '#ff9a9a' : '#a0d3ff');
      ctx.lineWidth = 3; ctx.beginPath();
      const px = Math.floor(player.x - cam) + player.w; const ex = Math.floor(enemy.x - cam); const y = player.y + player.h/2;
      ctx.moveTo(px, y); ctx.lineTo(ex, y); ctx.stroke();
    }

    for(const p of explosions){
      const alpha = Math.max(0, Math.min(1, p.life / 0.3));
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(Math.floor(p.x - cam), p.y, p.r, 0, Math.PI*2);
      ctx.fillStyle = p.color;
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    if(state.dead){
      const remain = Math.max(0, (state.respawnAt - ts)/1000);
      ctx.globalAlpha = 0.75; ctx.fillStyle = '#000'; ctx.fillRect(0,0,cv.width,cv.height); ctx.globalAlpha = 1;
      ctx.fillStyle = '#fff'; ctx.font = '16px system-ui, sans-serif';
      const msg = `사망! ${remain.toFixed(1)}초 후 부활 (클릭 시 즉시)`; const tw = ctx.measureText(msg).width;
      ctx.fillText(msg, (cv.width - tw)/2, 80);
    }

    {
      const now = ts;
      const ready = !state.dashActive && now >= state.dashCdUntil;
      const ratio = state.dashActive ? 1 : (ready ? 1 : Math.max(0, 1 - (state.dashCdUntil - now)/DASH.CD));
      const bw = cv.width - 40, bh = 10, bx = 20, by = cv.height - 16;
      ctx.fillStyle = '#1a2130'; ctx.fillRect(bx, by, bw, bh);
      ctx.fillStyle = ready ? '#6cf' : '#44607a';
      ctx.fillRect(bx, by, bw * Math.min(1, ratio), bh);
      ctx.font = '12px system-ui, sans-serif';
      ctx.fillStyle = '#d7eaff';
      let text = state.dashActive ? '대시 중' : (ready ? '대시 준비됨 (Space)' : `대시 쿨다운 ${(Math.max(0,(state.dashCdUntil - now))/1000).toFixed(1)}s`);
      const tw = ctx.measureText(text).width;
      ctx.fillText(text, (cv.width - tw)/2, by - 4);
    }

    if(toastTimer > 0){
      const a = Math.min(1, toastTimer / 0.3, (1.8 - toastTimer) / 0.3);
      ctx.globalAlpha = a; ctx.fillStyle = '#111826cc';
      const w = 320, h = 40; ctx.fillRect((cv.width - w)/2, 30, w, h);
      ctx.globalAlpha = a; ctx.fillStyle = '#e8f1ff'; ctx.font = '14px system-ui, sans-serif';
      ctx.fillText(toastMsg, (cv.width - w)/2 + 14, 30+25); ctx.globalAlpha = 1;
    }
  }

  function init(){
    loadManual();
    applyLevelUpgrades();
    document.getElementById('bossToggle').checked = prog.bossEnabled;
    requestSpawn();
    syncUI();
    requestAnimationFrame(tick);
  }
  init();
})();
</script>
</body>
</html>
